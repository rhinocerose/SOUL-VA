/** GNU GPLv3 License

    Copyright (C) 2021 ZheDeng
    TheZheDeng@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/** SOUL-VA (https://github.com/thezhe/SOUL-VA)

    The following interface is nearly identical to soul::filters EXCEPT:
    - Each effect is a 'Processor' under 'VA::HighLevel'
    - No user-defined types:
        *'SampleType' is float64<2>
        *The internal 'CoeffType' is float64<2>
        *Coefficient 'updateInterval' is every 1024 samples at 44.1kHz 
        or scaled as needed (i.e. every 2048 samples at 88.2kHz)
    - Parameters not suitable for modulation up through 20Hz include '(Unsmoothed)' in their annotations
    - Expanded set of vector-friendly functions (see 'Vectorized Intrinsic/Helper' sections)
    - 44.1kHz is the recommended sampling rate, but rates up through 96kHz are supported
    - Each section is marked with a date of last stable update (MM/DD/YYYY)
*/

/** Task List

    Current Tasks:
    - CompColorLan
    - add mixpan/dc blocker to all high level and add to snippet
    - add variable 2nd order hpf up to butterworth for comp
    - volume last after mixpan

    Future Tasks:
    - add butterworth constants
    - reorganize constants to Processor scopes
    - small dx approximation for hysteretic L
    - TheBass abs before stereo link and rectified lan
    - add state reset in adaa snippets (not part of update call for flexibility but add to if recalc)
    - add updateSample to snippets
    - Add more static_assert checks
    - convert Omega endpoints to cutoff endpoints for consistency
    - Ladder compile time order
*/

namespace VA 
{
/*==============================================================================
VA::HighLevel Processors                                                01/05/21
==============================================================================*/

    /** High-level Processors made of components from 'VA' and 'soul' namespaces 
    
        ALL effects can behave nonlinearly and add their own 'virtual analog warmth' 
    */
    namespace HighLevel
    {   
        /** Compressor with a colored CTF and nonlinear ballistics */
        namespace CompColorLan
        {
            graph Processor(float iStereoLinkPercent = 0,
                            float iAttackMs = 1,
                            float iAttackNonlinearity = 100,
                            float iReleaseMs = 300, 
                            float iReleaseNonlinearity = 0,
                            float iThreshold_dB = -20,
                            float iRatio0 = 10,
                            float iRatio1 = 1.5f,
                            float iHeight_dB = 6,
                            float iWidth_dB = 3,
                            float iHpfCutoffHz = 5,
                            float iHpfQuality = 1,
                            float iMixPercent = 100,
                            float iPan = 0,
                            float iMakeupVolume_dB = 0)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    stereoLink.stereoLinkIn;

                    ballisticsFilterLan.attackIn;
                    ballisticsFilterLan.attackNonlinearityIn;
                    ballisticsFilterLan.releaseIn;
                    ballisticsFilterLan.releaseNonlinearityIn;

                    ctfColor.thresholdIn;
                    ctfColor.ratio0In;
                    ctfColor.ratio1In;
                    ctfColor.heightIn;
                    ctfColor.widthIn;

                    svf.frequencyIn cutoffIn [[ name: "Cutoff", min: 1, max: 500, init: iHpfCutoffHz, unit: "Hz"]];
                    svf.qualityIn [[ name: "Q", min: 0.01, max: 0.707106781, init: iHpfQuality]]; //max Q is butterworth

                    smoothedVolume.volumeIn makeupVolumeIn [[ name: "Makeup Volume", min: -12, max: 12, init: iMakeupVolume_dB, step: 0.1f, unit: "dB" ]];
                    smoothedMixPan.mixIn;
                    smoothedMixPan.panIn;
                }
        
                let
                {
                    //main Processors
                    pAbs = Abs::Processor;

                    svf = filt::tpt::svf::Processor (iHpfCutoffHz, iHpfQuality);

                    ballisticsFilterLan = BallisticsFilterLan::Processor (iAttackMs, iAttackNonlinearity, iReleaseMs, iReleaseNonlinearity);
                    ctfColor = CTF_Color::Processor (iThreshold_dB, iRatio0, iRatio1, iHeight_dB, iWidth_dB);

                    applyGain = ApplyGain::Processor;


                    //boilerplate Processors
                    dcBlockerIn = filt::dc_blocker::Processor (DC_BLOCKER_CUTOFF_HZ);
                    dcBlockerOut = filt::dc_blocker::Processor (DC_BLOCKER_CUTOFF_HZ);

                    stereoLink = StereoLink::Processor (iStereoLinkPercent);

                    smoothedVolume = SmoothedVolume::Processor (iMakeupVolume_dB);
                    smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);
                }
        
                connection
                {
                    in -> dcBlockerIn -> smoothedMixPan.in0, svf.in, applyGain.in;
                    
                    svf.highpassOut -> pAbs -> stereoLink.in;
                    stereoLink.out -> ballisticsFilterLan.in;
                    ballisticsFilterLan.out -> ctfColor.in;
                    ctfColor.out -> applyGain.b;

                    applyGain.out -> smoothedMixPan.in1;
                    smoothedMixPan.out -> smoothedVolume.in;
                    smoothedVolume.out -> dcBlockerOut -> out;
                }
            }
        }

        /** Modulated 'DelayLine' with 'LadderLpfS' attached to its output

            a.k.a 'TheChorus'
        
            Notes:
            - 'delayIn' is not artifact free under modulation
            - Use case: Chorus, slow flange, doubler
            - Loosely based on Boss CE2 Chorus Pedal (lfo is trangle signal)
        */
        namespace ChorusLadderLpfS
        {
            graph Processor (float iDepthPercent = 50,
                            float iRateHz = 1.5f,
                            float iDelayMs = 27,
                            float iNonlinearity = 4.5f,
                            float iResonance = 0.15f,
                            float iCutoffHz = 16000,
                            float iMixPercent = 50,
                            float iPan = -1.f,
                            float iMakeupVolume_dB = 0)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                { 
                    lfo.depthIn [[ name: "Depth", min: 0, max: 100, init: iDepthPercent, unit: "%", step: 1 ]];
                    lfo.rateHzIn rateIn [[ name: "Rate", min: 0.1, max: 4.0, init: iRateHz, unit: "Hz", step: 0.1 ]];
                    delayLine.delayIn [[ name: "Delay (Unsmoothed)", min: 0, max: 35, init: iDelayMs, unit: "ms", step: 1 ]];

                    ladderLpfS.nonlinearityIn;
                    ladderLpfS.resonanceIn;
                    ladderLpfS.cutoffIn;

                    smoothedMixPan.mixIn;
                    smoothedMixPan.panIn;
                    smoothedVolume.volumeIn makeupVolumeIn [[ name: "Makeup Volume", min: -6, max: 6, init: iMakeupVolume_dB, step: 0.1f, unit: "dB" ]];
                }
        
                let
                {
                    dcBlockerIn = filt::dc_blocker::Processor (DC_BLOCKER_CUTOFF_HZ);
                    dcBlockerOut = filt::dc_blocker::Processor (DC_BLOCKER_CUTOFF_HZ);

                    lfo = osc::lfo::Processor;
                    delayLine = DelayLine::Processor (iDelayMs, 35, 4);

                    ladderLpfS = LadderLpfS::Processor (iCutoffHz, iResonance, iNonlinearity);

                    smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);
                    smoothedVolume = SmoothedVolume::Processor (iMakeupVolume_dB);
                }
        
                connection
                {
                    lfo.out -> delayLine.lfoIn;
                    
                    in -> dcBlockerIn -> delayLine.in, smoothedMixPan.in0;
                    
                    delayLine.out -> ladderLpfS.in;
                    ladderLpfS.out -> smoothedMixPan.in1;
                    
                    smoothedMixPan.out -> smoothedVolume.in;
                    smoothedVolume.out -> dcBlockerOut -> out;
                }
            }
        }

        /** 'OnepoleC' in all pass mode modulated by 'LanADAA' 

            a.k.a. 'TheBass'
        
            Use case: Boost and sustain low frequencies
            
            'nonlinearityIn' can modulate using low lfo frequencies, but this isn't recommended
        */
        namespace OnepoleC_Lan
        {
            graph Processor (float iNonlinearity = 250, float iStereoLinkPercent = 100)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    event float nonlinearityIn [[ name: "Nonlinearity (Unsmoothed)", min: 0, max: 350, init: iNonlinearity, step: 1]];
                    stereoLink.stereoLinkIn;
                    autoSmoothedVolume.parameterIn volumeIn;
                    //smoothedMixPan.mixIn;
                    //smoothedMixPan.panIn;
                }
        
                let
                {
                    dcBlockerIn = filt::dc_blocker::Processor (0.1);

                    stereoLink = StereoLink::Processor (iStereoLinkPercent);

                    internal = Internal::Processor (iNonlinearity) * 2;
                    onepoleMixer = OnepoleMixer::Processor (OnepoleMixer::Modes::APF);

                    autoSmoothedVolume = AutoSmoothedVolume::Processor (AutoParameter::Modes::Volume_OnepoleC_Lan);
                   // smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);
                }
        
                connection
                {
                    nonlinearityIn -> internal.nonlinearityIn;
                    nonlinearityIn -> autoSmoothedVolume.controlIn;

                    in -> dcBlockerIn -> stereoLink.in, internal.in;

                    stereoLink.out -> internal.Lin;

                    internal.highpassOut -> onepoleMixer.highpassIn;
                    internal.lowpassOut -> onepoleMixer.lowpassIn;
                    
                    onepoleMixer.out -> autoSmoothedVolume.in;
                    autoSmoothedVolume.out -> out; 
                }
            }

            namespace Internal 
            {
                graph Processor (float iNonlinearity = 0)
                {
                    input stream SampleType in, Lin;
                    output stream SampleType highpassOut, lowpassOut;
            
                    input
                    {
                        L.nonlinearityIn;
                    }

                    let
                    {
                        L = LanADAA::Processor (iNonlinearity);
                        onepoleC = OnepoleC::Processor;
                    }
            
                    connection
                    {
                        in -> onepoleC.in;

                        Lin -> L.in;
                        L.Omega -> onepoleC.Omega;

                        onepoleC.highpassOut -> highpassOut;
                        onepoleC.lowpassOut -> lowpassOut;
                    }
                }
            }    
        }

        /** A dummy processor that doesn't modify streams
        
            Use case: Debugging
        */
        namespace Dummy
        {
            graph Processor()
            {
                input stream SampleType in;
                output stream SampleType out;
                
                connection
                {
                    in -> out;
                }
            }
        }
    } //namespace HighLevel

/*==============================================================================
Filter Processors                                                       01/05/21
==============================================================================*/

    /** Ladder Low Pass Filter with variable order and saturating state 
    
        Notes:
        - currently hard-coded to 4th order lpf
        - Resonance up to 2 reccomended
        - Even though its nonlinear, the filter can become unstable if using an unbounded nonlinearity
          i.e., the filter can self-oscillate with nonlinear functions like 'tanh'
    */
    namespace LadderLpfS
    {       
        let oversampling = 2;

        graph Processor (float iCutoff = 10000, float iResonance = 1, float iNonlinearity = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in0 cutoffIn [[ name: "Cutoff", min: 1000, max: 16000, init: iCutoff, unit: "Hz", step: 1 ]];
                smoothedParameter1.in0 resonanceIn [[ name: "Resonance", min: 0, max: 0.25f, init: iResonance, step: 0.01f ]];
                internal.nonlinearityIn;
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (float[] (iCutoff), SmoothedParameter::Modes::G_Onepole, 2);
                smoothedParameter1 = SmoothedParameter::Processor (float[] (iResonance), SmoothedParameter::Modes::Linear);
                
                internal = Internal::Processor (iNonlinearity) * oversampling;
            }
    
            connection
            {
                smoothedParameter0.out0 -> internal.G_OnepoleIn;
                smoothedParameter1.out0 -> internal.kIn;

                in -> internal.in;
                internal.out -> out;
            }
        }
    
        namespace Internal
        {   
            struct Coeffs
            {
                SampleType g; //G for onepole stages
                SampleType k; //resonance
                SampleType N; //nonlinearity
            }

            void updatePerSample (Coeffs& c, SampleType G_Onepole, SampleType k)
            {
                c.g = G_Onepole;
                c.k = k;
            }

            namespace M (int order)
            {
                static_assert (order % 2 == 0, "LadderFilter::M [[Filter Processors]]");

                void update (Coeffs& c, float nonlinearity, State& s, float64 fs)
                {
                    c.N = float (44100 * oversampling / fs) * nonlinearity * float (c.g[0]) * (1.f + float (c.k[0])); //nonlinearity scaled according to fs and other params
                }

                struct State
                {
                    SampleType[order] s;
                }

                SampleType process (State& s, SampleType x, const Coeffs& c)
                {
                    var S = ZERO;
                    var G = ONE;
                    for (int i = order - 1; i > -1; --i)
                    {
                        S += G * s.s.at(i);
                        G *= c.g;
                    }

                    //input to first lowpass ('u')
                    var y = (x - c.k * S) / (ONE + c.k * G);

                    //'order' lowpasses in series 
                    for (int i = 0; i < order; ++i)
                    {
                        let v = (y - s.s.at(i)) * c.g;
                        
                        if (i != 3) //the last lpf has 'state saturation'
                        {
                           y = v  + s.s.at(i);
                           s.s.at(i) = v + y;
                        }
                        else //2 stage saturation, bounded clipper
                        {
                            y = vsigmoidCD(vBBD(v + s.s.at(i), c.N));
                            s.s.at(i) = vsigmoidCD(vBBD(v + y, c.N));
                        }     
                    }
                    
                    return y * (ONE + c.k); //normalize
                }
            }
        
            processor Processor (float iNonlinearity = 0, int order = 4)
            {
                input stream SampleType in;
                output stream SampleType out;

                input stream SampleType G_OnepoleIn, kIn;

                input event float nonlinearityIn [[ name: "Nonlinearity (Unsmoothed)", min: 0, max: 20, init: iNonlinearity, step: 0.1]];

                event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
                float nonlinearity = iNonlinearity;
                bool recalc = true;

                static_assert (order == 4, "LadderLpfS::Processor [[Filter Processors]] Other filter orders not yet implemented.");
        
                void run()
                {   
                    M(order)::State s;
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;

                            M(order)::update (c, nonlinearity, s, processor.frequency);
                        }

                        loop (updateIntervalSamples)
                        {
                            c.updatePerSample (G_OnepoleIn, kIn);                            

                            out << M(order)::process (s, in, c);

                            advance();
                        }
                    }
                }
            }
        }
    }

    /** 'OnepoleC' with differing cutoff depending on rising/falling output relative to stored output (feedback) */
    namespace BallisticsFilterLan
    {
        graph Processor (float iAttack = 1,
                        float iAttackNonlinearity = 0,
                        float iRelease = 100,
                        float iReleaseNonlinearity = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                branchingCutoffLan.attackIn;
                branchingCutoffLan.attackNonlinearityIn;
                branchingCutoffLan.releaseIn;
                branchingCutoffLan.releaseNonlinearityIn;
            }
    
            let
            {
                branchingCutoffLan = BranchingCutoffLan::Processor (iAttack, iAttackNonlinearity, iRelease, iReleaseNonlinearity);
                onepoleC = OnepoleC::Processor;
            }
    
            connection
            {
                in -> onepoleC.in;

                in -> branchingCutoffLan.x;
                onepoleC.lowpassOut -> [1] -> branchingCutoffLan.y;
                branchingCutoffLan.Omega -> onepoleC.Omega;

                onepoleC.lowpassOut -> out;
            }
        }

        namespace BranchingCutoffLan
        {
            struct Coeffs 
            {
                Lan::Coeffs attack;
                Lan::Coeffs release;
            }

            void update (Coeffs& c, float attack, float attackNonlinearity, float release, float releaseNonlinearity) 
            {
                Lan::update (c.attack, attack, attackNonlinearity);
                Lan::update (c.release, release, releaseNonlinearity);
            }

            SampleType process (SampleType x, SampleType y, const Coeffs& c) 
            {
                return vifgt (Lan::process (x, c.attack), Lan::process(x, c.release), x, y);  
            }

            processor Processor(float iAttack,
                                float iAttackNonlinearity,
                                float iRelease,
                                float iReleaseNonlinearity)
            {
                input stream SampleType x, y;
                output stream SampleType Omega;
        
                input event
                { 
                    float attackIn [[ name: "Attack", min: 1, max: 100, init: iAttack, unit: "ms", step: 1 ]];
                    float attackNonlinearityIn [[ name: "Attack Nonlinearity", min: 0, max: 20, init: iAttackNonlinearity, step: 1 ]];
                    float releaseIn [[ name: "Release", min: 20, max: 5000, init: iRelease, unit: "ms", step: 1 ]];
                    float releaseNonlinearityIn [[ name: "Release Nonlinearity", min: 0, max: 20, init: iReleaseNonlinearity, step: 1]];
                }

                event attackIn (float v) { attack = v; recalc = true; }
                event attackNonlinearityIn (float v) { attackNonlinearity = v; recalc = true; }
                event releaseIn (float v) { release = v; recalc = true; }
                event releaseNonlinearityIn (float v) { releaseNonlinearity = v; recalc = true; }

                float attack = iAttack;
                float attackNonlinearity = iAttackNonlinearity;
                float release = iRelease;
                float releaseNonlinearity = iReleaseNonlinearity;
                bool recalc = true;
        
                void run()
                {
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            c.update (attack, attackNonlinearity, release, releaseNonlinearity);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            Omega << process (x, y, c);

                            advance();
                        }
                    }
                }
            }
        }
    }

    /** Mix outputs from Onepole to make more complicated frequency responses */
    namespace OnepoleMixer
    {   
        namespace Modes
        {
            let HPF = 0;
            let LPF = 1;
            let APF = 2;
            let NumModes = 3;
        }

        struct Coeffs
        {
            int m;
        }
    
        void update (Coeffs& c, float mode)
        {
            c.m = int (mode);
        }
    
        SampleType process (SampleType hpf, SampleType lpf, const Coeffs& c)
        {
            if (c.m == Modes::HPF)
                return hpf;
            else if (c.m == Modes::LPF)
                return lpf;
            else
                return lpf - hpf;
        }
    
        processor Processor (int iMode = Modes::HPF)
        {
            input stream SampleType lowpassIn, highpassIn;
            output stream SampleType out;
    
            input event float modeIn [[ name: "Mode", min: Modes::HPF, max: Modes::NumModes - 1, init: iMode, text: "HPF|LPF|APF" ]];

            static_assert ((iMode > -1) && (iMode < Modes::NumModes), "OnepoleMixer::Processor [[Filter Processors]]");
    
            event modeIn (float v) { mode = v; recalc = true; }
    
            float mode = float (iMode);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (mode);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (highpassIn, lowpassIn, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** soul::filters::tpt::onepole modified for angular cutoff modulation
        
        - If sampling rate is 44.1kHz and an accurate frequency response is important, use 2x oversampling
        - Structure is more consistent with SVF and oversampling is used instead of prewarping when compared to soul::filters::tpt::onepole
    */
    namespace OnepoleC
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        void updatePerSample (Coeffs& c, SampleType Omega, float64 fs)
        {
            c.G = vcutoffToG_OnepoleA (Omega, fs);
        }

        SampleType[2] process (State& s, SampleType x, const Coeffs& c)
        {
            let v = (x - s.s) * c.G;
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = v + lpf;

            return SampleType[2] (lpf, hpf);
        }

        processor Processor
        {
            input stream SampleType in;
            input stream SampleType Omega;
            output stream SampleType lowpassOut, highpassOut;

            void run()
            {   
                State s;
                Coeffs c;

                let fs = processor.frequency;

                loop
                {
                    c.updatePerSample (Omega, fs);

                    let y = process (s, in, c);

                    lowpassOut << y.at(0);
                    highpassOut << y.at(1);

                    advance();
                }
            }
        }
    }

    /** Variable order DC blocker using soul::filters::dc_blocker */
    namespace DC_BlockerN
    {   
        namespace M (int order)
        {
            struct Coeffs
            {
                filt::dc_blocker::Coeffs[order] coeffs;
            }

            void update (Coeffs& c, float64 SampleRate, float64 freqHz)
            {
                for (int i = 0; i < order; ++i)
                    filt::dc_blocker::update (c.coeffs.at(i), SampleRate, freqHz);
            }

            struct State
            {
                filt::dc_blocker::State[order] state;
            }

            SampleType process (State& s, SampleType x, Coeffs& c)
            {
                var y = filt::dc_blocker::process (s.state.at(0), x, c.coeffs.at(0));

                for (int i = 1; i < order; ++i)
                    y = filt::dc_blocker::process (s.state.at(i), y, c.coeffs.at(i));

                return y;
            }
        }
    
        processor Processor (int order = 1, float64 frequency = DC_BLOCKER_CUTOFF_HZ)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {   
                M(order)::State s;
                M(order)::Coeffs c;
    
                M(order)::update (c, processor.frequency, frequency);

                loop
                {
                    out << M(order)::process (s, in, c);

                    advance();
                }
            }
        }
    }

    /** Modified version of https://soul.dev/lab/?id=Delay 
    
        For feedback make a loop with a unit delay (i.e. DelayLine.out -> [1] -> add your effects here -> DelayLine.in)
    */
    namespace DelayLine
    {   
        namespace M (float maxDelayMs, float maxDepthMs)
        {
            static_assert ((maxDelayMs + maxDepthMs) < float (MAX_BUFFER_SIZE_MS), "DelayLine::M [[Filter Processors]]");
            
            let maxBufferSize = int (((maxDelayMs + maxDepthMs) / float (MAX_BUFFER_SIZE_MS)) * float (MAX_BUFFER_SIZE));

            struct State 
            {
                wrap<maxBufferSize> readPos, writePos;
                SampleType[maxBufferSize] buf;
            }

            void update (State& s, float delayMs, float fs)
            {
                let fsDiv1k = fs / 1000.f;

                s.readPos = wrap<maxBufferSize> (s.writePos - int (fsDiv1k * delayMs));
            }

            SampleType process (State& s, SampleType x, float lfo, float fs)
            {
                let maxDepthSamples = maxDepthMs * fs / 1000.f;

                s.buf.at (s.writePos) = x;

                let y = s.buf.readLinearInterpolated (float (s.readPos) - maxDepthSamples * lfo);

                ++s.readPos;
                ++s.writePos;

                return y;
            }
        }

        processor Processor (float iDelayMs = 3, float maxDelayMs = 20, float maxDepthMs = 4)
        {
            input stream SampleType in;
            input stream float lfoIn; //max amplitude should be <= 1
            output stream SampleType out;

            input event float delayIn [[ name: "Delay (Unsmoothed)", min: 0, max: maxDelayMs, init: iDelayMs, unit: "ms", step: 1 ]];

            event delayIn (float v) { delayMs = v; recalc = true; }

            float delayMs = iDelayMs;
            bool recalc = true;

            static_assert (iDelayMs <= maxDelayMs, "DelayLine::Processor [[Filter Processors]]'");

            namespace m = M (maxDelayMs, maxDepthMs);

            void run()
            {  
                m::State s;
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
                let fs = float (processor.frequency);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        m::update (s, delayMs, fs);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << m::process (s, in, lfoIn, fs);

                        advance();
                    }
                }
            }
        }
    }
    
/*==============================================================================
Mix Processors                                                          12/14/21
==============================================================================*/
    
    /** Apply a volume via 'AutoParameter' and 'SmoothedVolume' */
    namespace AutoSmoothedVolume
    {
        graph Processor(int mode = AutoParameter::Modes::Volume_OnepoleC_Lan)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                autoParameter.parameterIn;
                autoParameter.controlIn;
            }
    
            let
            {
                autoParameter = AutoParameter::Processor (mode);
                smoothedVolume = SmoothedVolume::Processor (AutoParameter::M(mode)::iParameter);
            }
    
            connection
            {
                autoParameter.out -> smoothedVolume.volumeIn;

                in -> smoothedVolume.in;
                smoothedVolume.out -> out;
            }
        }
    }

    /** Apply mixing and panning via 'SmoothedParameter' */
    namespace SmoothedMixPan
    {
        graph Processor(float iMix = 50, float iPan = 0)
        {
            input stream SampleType in0, in1;
            output stream SampleType out;
    
            input
            {
                smoothedGains.in0 mixIn [[ name: "Mix", min: 0, max: 100, init: iMix, unit: "%", step: 1 ]];
                smoothedGains.in1 panIn [[ name: "Pan", min: -1, max: 1, init: iPan, step: 0.01f ]];
            }

            let
            {
                smoothedGains = SmoothedParameter::Processor (float[2] (iMix, iPan), SmoothedParameter::Modes::MixPan);
                applyGains = ApplyGains::Processor;
            }
    
            connection
            {
                smoothedGains.out0 -> applyGains.b0;
                smoothedGains.out1 -> applyGains.b1;

                in0 -> applyGains.in0;
                in1 -> applyGains.in1;

                applyGains.out -> out;
            }
        }
    }
    
    /** Apply a volume via 'SmoothedParameter' */
    namespace SmoothedVolume
    {
        graph Processor (float iVolume = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float volumeIn [[ name: "Volume", min: -12, max: 0, init: iVolume, step: 0.1f, unit: "dB" ]];
    
            let
            {
                smoothedGain = SmoothedParameter::Processor (float[] (iVolume), SmoothedParameter::Modes::Decibel);
                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                in -> applyGain.in;
                
                volumeIn -> smoothedGain.in0;
                smoothedGain.out0 -> applyGain.b;

                applyGain.out -> out;
            }
        }
    }

/*==============================================================================
Vectorized Instrinsic/Helper Processors                                 01/05/22
==============================================================================*/

    /** vCTF_Color wrapper */
    namespace CTF_Color
    {
        struct Coeffs 
        {
            SampleType threshold;
            SampleType ratio0;
            SampleType ratio1;
            SampleType height;
            SampleType width; 
        }
    
        void update (Coeffs& c, float threshold, float ratio0, float ratio1, float colorHeight, float colorWidth) 
        {
            c.threshold = SampleType (threshold);
            c.ratio0 = SampleType (ratio0);
            c.ratio1 = SampleType (ratio1);
            c.height = SampleType (colorHeight);
            c.width = SampleType (colorWidth);
        }
    
        SampleType process (SampleType x, const Coeffs& c) 
        {
            return vCTF_Color (x, c.threshold, c.ratio0, c.ratio1, c.height, c.width);
        }

        processor Processor(float iThreshold = -30,
                            float iRatio0 = 2,
                            float iRatio1 = 2,
                            float iHeight = 6,
                            float iWidth = 6)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: iThreshold, unit: "dB", step: 0.1f ]];
            input event float ratio0In [[ name: "Downwards Ratio", min: 1.f, max: 20.f, init: iRatio0, step: 1 ]];
            input event float ratio1In [[ name: "Updwards Ratio", min: 1.f, max: 1.5f, init: iRatio1, step: 0.01f ]];
            input event float heightIn [[ name: "Height", min: -6.f, max: 6.f, init: iHeight, unit: "dB", step: 0.01f ]];
            input event float widthIn [[ name: "Width", min: 1.f, max: 6.f, init: iWidth, unit: "dB", step: 0.01f ]];

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratio0In (float v) { ratio0 = v; recalc = true; }
            event ratio1In (float v) { ratio1 = v; recalc = true; }
            event heightIn (float v) { height = v; recalc = true; }
            event widthIn (float v) { width = v; recalc = true; }

            float threshold = iThreshold;
            float ratio0 = iRatio0;
            float ratio1 = iRatio1;
            float height = iHeight;
            float width = iWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio0, ratio1, height, width);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Average a SampleType stream with a copy that has swapped channels */
    namespace StereoLink
    {   
        struct Coeffs
        {
            SampleType[2] b;
            float stereoLink;
        }
    
        void update (Coeffs& c, float stereoLink)
        {
            c.b = vmixToGains (stereoLink * 0.5f);
            c.stereoLink = stereoLink;
        }
    
        SampleType process (SampleType x, const Coeffs& c)
        {
            if (c.stereoLink == 0.f)
                return x;
            else if (c.stereoLink == 100.f)
                return SampleType (x.sum()/x.size);
            else
            {
                let x1 = SampleType (x[1] , x[0]);

                return c.b.at(0) * x + c.b.at(1) * x1;
            }
        }
    
        processor Processor (float iStereoLink = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float stereoLinkIn [[ name: "Stereo Link", min: 0, max: 100, init: iStereoLink, unit: "%", step: 1 ]];
            
            event stereoLinkIn (float v) { stereoLink = v; recalc = true; }

            float stereoLink = iStereoLink;
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency/44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (stereoLink);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Bucket Brigade Device Waveshaper
    
        Notes:
        - dynamic ADAA specifically optimized for 'LadderLpfS'
        - If sampling rate is 44.1kHz, use 2x oversampling
        - Parameters are not suitable for modulation
    */
    namespace BBD_ADAA
    {   
        struct Coeffs
        {
            SampleType N;
        }
    
        void update (Coeffs& c, float nonlinearity)
        {
            c.N = nonlinearity;
        }    
    
        SampleType f (SampleType x, const Coeffs& c)
        {
            return vBBD(x, c.N);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            let c1 = c.N * SampleType (1.0/8.0);
            let c2 = c.N * SampleType (1.0/16.0);
            
            return HALF * vpow(x, 2) - c1 * SampleType(1.0 / 3.0) * vpow (x, 3) - c2 * SampleType (1.0 / 4.0) * vpow (x, 4);
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            let c1 = c.N * SampleType (1.0/8.0);
            let c2 = c.N * SampleType (1.0/16.0);
            
            return SampleType (1.0 / 6.0) * vpow (x, 3) - c1 * SampleType(1.0 / 12.0) * vpow (x, 4) - c2 * SampleType (1.0 / 20.0) * vpow (x, 5);
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
        
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }
    
        SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        {
            //Find F1_0
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = HALF * (x + s.x_2);
            let delta = xBar - s.x_1;
    
            let f_0 = viflt (
                viflt (
                    f (HALF * (xBar + s.x_1), c),
                    (TWO / delta) * (F1 (xBar, c) + (s.F2_1 - F2 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), ADAA_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType processADAA1 (State& s, SampleType x, const Coeffs& c)
        {
            //Find f_0
            let x_0mx_1 = x - s.x_1;
            let F1_0 = F1 (x, c);
    
            let f_0 = viflt (f (HALF * (x + s.x_1), c), 
                (F1_0 - s.F1_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //update s
            s.x_1 = x;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, const Coeffs& c)
        {
               return s.processADAA1 (x, c);
        }
    
        processor Processor(float iNonlinearity = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float nonlinearityIn [[ name: "Nonlinearity (Unsmoothed)", min: 0, max: 3.5, init: iNonlinearity, step: 0.1]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
            float nonlinearity = iNonlinearity;
            bool recalc = true;
    
            void run()
            {
                State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (nonlinearity);
                        s.reset();
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << s.process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** 'vLan' with ADAA and a linear angular cutoff of 2pi
    
        Notes:
        - Optimized for use with OnepoleC or modulating frequency domain filters
        - Use with 2x oversampling
    */
    namespace LanADAA
    {   
        struct Coeffs
        {
            SampleType N;
        }
    
        void update (Coeffs& c, float nonlinearity)
        {
            c.N = SampleType (nonlinearity);
        }    
    
        SampleType f (SampleType x, const Coeffs& c)
        {
            return vLan (x, c.N);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            return vpow (x, 3) * vpow (c.N, 2) * SampleType (1.0 / 3.0) + c.N * vpow (x, 2) * vsgn (x) + x;
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            return vpow (x, 2) * (HALF + c.N * SampleType (1.0 / 3.0) * x * vsgn (x) + vpow (c.N, 2) * SampleType (1.0 / 12.0) * vpow (x, 2));
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }

        SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        {
            //Find F1_0
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = HALF * (x + s.x_2);
            let delta = xBar - s.x_1;
    
            let f_0 = viflt (
                viflt (
                    f (HALF * (xBar + s.x_1), c),
                    (TWO / delta) * (F1 (xBar, c) + (s.F2_1 - F2 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), ADAA_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, const Coeffs& c)
        {
            return s.processADAA2 (x, c);
        }
    
        processor Processor (float iNonlinearity = 0)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlinearity (Unsmoothed)", min: 0, max: 350, init: iNonlinearity, step: 1]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
            float nonlinearity = iNonlinearity;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity);
                        s.reset();
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << (SampleType (twoPi - 1) + s.process (in, c));

                        advance();
                    }
                }
            }
        }
    }

    /** 'vLan' Processor wrapper
    
        Optimized for use with step-reponse filter effects
    */
    namespace Lan
    {   
        struct Coeffs
        {
            SampleType N;
            SampleType bias;
        }
    
        void update (Coeffs& c, float tau, float nonlinearity)
        {
            c.N = SampleType (nonlinearity);
            c.bias = SampleType (1000.0) / SampleType (tau) - ONE;
        }    

        SampleType process (SampleType x, const Coeffs& c)
        {
            return c.bias + vLan (x, c.N);
        }
    
        processor Processor (float iNonlinearity = 0, float iTau = 20)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 275, init: iNonlinearity, step: 1 ]];
            input event float tauIn [[ name: "Tau", min: 0, max: 500, init: iTau, step: 1 ]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            event tauIn (float v) { tau = v; recalc = true; }

            float tau = iTau;
            float nonlinearity = iNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (tau, nonlinearity);
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << process (in, c);

                        advance();
                    }
                }
            }
        }
    }

    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    namespace ApplyGain
    {
        processor Processor
        {
            input stream SampleType b;
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b * in;
    
                    advance();
                }
            }
        }
    }

    namespace ApplyGains
    {
        processor Processor
        {
            input stream SampleType b0, b1;
            input stream SampleType in0, in1;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b0 * in0 + b1 * in1;
    
                    advance();
                }
            }
        }
    }

/*==============================================================================
Parameter Processors                                                    01/05/21
==============================================================================*/

    /** Automatic/manual parameters

        Notes:
        - Use to control a event float endpoint
        - Passes events from 'parameterIn' to 'out' unless the current value of 'parameterIn' is below the mode's MinManualParameter.
        'controlIn' is mapped to 'out' in this case ('out' is automatically determined by 'controlIn')
        - Currently only for makeup volume
    */
    namespace AutoParameter
    {   
        namespace Modes
        {
            let Volume_OnepoleC_Lan = 0;
            let NumModes = 1;
        }

        namespace M (int mode = Modes::Volume_OnepoleC_Lan)
        {
            static_assert ((mode > -1) && (mode < Modes::NumModes), "AutoParameter [[Parameter Processors]]");

            let MaxParameter = (mode == Modes::Volume_OnepoleC_Lan ? 0.f : 0.f);
            let MinParameter = (mode == Modes::Volume_OnepoleC_Lan ? -6.1f : -6.1f);
            let iParameter = (mode == Modes::Volume_OnepoleC_Lan ? MinParameter : MinParameter);
            let Step = (mode == Modes::Volume_OnepoleC_Lan ? 0.1f : 0.1f);
            let MinManualParameter = (mode == Modes::Volume_OnepoleC_Lan ? MinParameter + Step : MinParameter + Step);
            let PtsSize = (mode == Modes::Volume_OnepoleC_Lan ? 4 : 1);
            let Pts = (mode == Modes::Volume_OnepoleC_Lan ? float[PtsSize] (-0.f, -1.f, -2.f, -3.5f) : float[PtsSize] (0));

            float update (float parameter, float control)
            {
                if (parameter < MinManualParameter)
                {
                    if const (mode == Modes::Volume_OnepoleC_Lan)
                        return Pts.readLinearInterpolated (min (control * 0.1f, 3.f));
                }
                else
                    return parameter; 
            }
        }

        processor Processor (int mode = Modes::Volume_OnepoleC_Lan)
        {
            output event float out;

            input event float parameterIn [[name: "Volume", min: M (mode)::MinParameter, max: M(mode)::MaxParameter, init: M(mode)::iParameter, step: M(mode)::Step, unit: "dB"]];
            input event float controlIn;

            event parameterIn (float v) { parameter = v; recalc = true; }
            event controlIn (float v) { control = v; recalc = true; }

            float parameter = M(mode)::iParameter;
            float control;
            bool recalc = true;

            void run() 
            { 
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        out << M(mode)::update (parameter, control);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        advance();
                    }
                }
            }
        }
    }

    /** Maps float event(s) to smoothed output SampleType stream(s); heavily modified version of soul::gain::SmoothedGainParameter

        Modes:
        - Linear: Maps unsmoothed (in0) to smoothed (out0)
        - Decibel: Maps unsmoothed dB scale (in0) to smoothed linear scale (out0)
        - MixPan: Maps unsmoothed mix and pan (in0, in1) to smoothed gains for mixing two SampleType streams via ApplyGains (out0, out1)
        - G_Onepole: Maps unsmoothed cutoff in Hz (in0) to smoothed Onepole cutoff gain (out0) 

        Note:
        - initial parameter is a float[] that defines the initial value of the parameter(s) corresponding to each of the float event(s)
        - 'slewRateSeconds' is NOT the same as in soul::gain::SmoothedGainParameter; it is the max change in linear gain per second
        (e.g., if slewRateSeconds 0.5 and gain changes by 1, then it will take 2 seconds to reach a gain of 1)  
        - This Processor may be modified in the future to include other one-to-one, one-to-two, two-to-one, or two-to-two event-stream mapping Modes
    */    
    namespace SmoothedParameter
    {
        namespace Modes
        {
            let Linear = 0;
            let Decibel = 1;
            let MixPan = 2;
            let G_Onepole = 3;
            let NumModes = 4;
        }

        namespace M (int mode = Modes::Linear)
        {
            static_assert ((mode > -1) && (mode < Modes::NumModes), "SmoothedParameter::M [[Parameter Processors]]");

            let NumIn = (mode == Modes::MixPan ? 2 : 1);
            let NumOut = (mode == Modes::MixPan ? 2 : 1);
            
            struct Coeffs
            {
                SampleType[NumOut] target;
                SampleType[NumOut] increment;
            }

            struct State
            {
                SampleType[NumOut] current;
                int remainingRampSamples;
            }

            void update (Coeffs& c, float[] parameter, State& s, SampleType divMaxDelta, float64 fs)
            {
                if const (mode == Modes::Linear)
                    c.target.at(0) = SampleType (parameter.at(0));
                else if const (mode == Modes::Decibel)
                    c.target.at(0) = vdBtoGain (SampleType (parameter.at(0)));
                else if const (mode == Modes::MixPan)
                    c.target = vmixPanToGains (parameter.at(0), parameter.at(1));
                else if const (mode == Modes::G_Onepole)
                    c.target.at(0) = vcutoffToG_Onepole (parameter.at(0), fs);

                if const (mode == Modes::Linear || mode == Modes::Decibel || mode == Modes::G_Onepole)
                    s.remainingRampSamples = int (vmax (ONE, vabs (c.target.at(0) - s.current.at(0)) * divMaxDelta) [0]);
                else if const (mode == Modes::MixPan)
                {
                    let r0 = int (vmaxr (vabs (c.target.at(0) - s.current.at(0)) * divMaxDelta));
                    let r1 = int (vmaxr (vabs (c.target.at(1) - s.current.at(1)) * divMaxDelta));
                    s.remainingRampSamples = max (1, max (r0, r1));
                }

                for (int i = 0; i < NumOut; ++i)
                    c.increment.at(i) = (c.target.at(i) - s.current.at(i)) / SampleType (s.remainingRampSamples);
            }

            void updateUnsmoothed (Coeffs& c, float[] parameter, State& s, float64 fs)
            {
                if const (mode == Modes::Linear)
                    s.current.at(0) = SampleType (parameter.at(0));
                else if const (mode == Modes::Decibel)
                    s.current.at(0) = vdBtoGain (SampleType (parameter.at(0)));
                else if const (mode == Modes::MixPan)
                    s.current = vmixPanToGains (parameter.at(0), parameter.at(1));
                else if const (mode == Modes::G_Onepole)
                    s.current.at(0) = vcutoffToG_Onepole (parameter.at(0), fs); 

                s.remainingRampSamples = 0;
            }

            SampleType[NumOut] process (State& s, const Coeffs& c)
            {
                if (s.remainingRampSamples != 0)
                {
                    if (--(s.remainingRampSamples) == 0)
                    {
                        for (int i = 0; i < s.current.size; ++i)
                            s.current.at(i) = c.target.at(i);
                    }
                    else
                    {
                        for (int i = 0; i < s.current.size; ++i)
                            s.current.at(i) += c.increment.at(i);
                    }
                }

                return s.current;
            }
        }

        processor Processor (float[] iParameter, int mode = Modes::Linear, int oversampling = 1, float slewRateSeconds = SLEW_RATE_SECONDS_GAIN)
        {
            output stream SampleType out0, out1;

            input event float in0, in1;

            event in0 (float v) { parameter.at(0) = v; recalc = true; }
            event in1 (float v) { parameter.at(1) = v; recalc = true; }

            float[2] parameter;
            bool recalc = false;

            static_assert (iParameter.size <= parameter.size, "SmoothedParameter::Processor [[Parameter Processors]]");
            static_assert (oversampling > 0, "SmoothedParameter::Processor [[ParameterProcessors]]");

            void init()
            {
                for (int i = 0; i < iParameter.size; ++i)
                    parameter.at(i) = iParameter.at(i);
            }

            void run()
            {   
                M(mode)::State s;
                M(mode)::Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
                let divMaxDelta = SampleType (float (processor.frequency) / slewRateSeconds);
                let fs = processor.frequency * float64 (oversampling);
    
                M(mode)::updateUnsmoothed (c, parameter, s, fs);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        M(mode)::update (c, parameter, s, divMaxDelta, fs);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        let y = M(mode)::process (s, c);

                        out0 << y.at(0);

                        if const (M(mode)::NumOut > 1)
                            out1 << y.at(1);

                        advance();
                    }
                }
            }
        }
    }

/*==============================================================================
Vectorized Helper Functions                                             12/13/21
==============================================================================*/

    /** Compressor Transfer Function (CTF) with additional color settings to shape the knee 
    
        Notes:
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-falseStatement-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    SampleType vCTF_Color (SampleType x, SampleType threshold, SampleType ratio0, SampleType ratio1, SampleType height, SampleType width)
    {
        let xdB = vgainTodB (x);
        let xdBmthr = xdB - threshold;

        let color = height / (ONE + vpow (xdBmthr * (ONE/width), 2));
        let ydB = vifgt (threshold + xdBmthr * (ONE/ratio0) + color, threshold + xdBmthr * (ONE/ratio1) + color, xdB, threshold);

        return vmin (vdBtoGain (ydB) / x, COMP_MAX_GAIN);
    }

    /** 'BBD' mapping from http://dafx10.iem.at/proceedings/papers/RaffelSmith_DAFx10_P42.pdf 
    
        Notes:
        - Use for low order, monotonically decreasing harmonics
        - Needs makeup gain
        - Harmonics boosted compared to the original version according to the linear gain b 
    */
    SampleType vBBD (SampleType x, SampleType b)
    {
        let c1 = b * SampleType (1.0/8.0);
        let c2 = b* SampleType (1.0/16.0);

        return x - c1 * vpow (x, 2) - c2 * vpow (x, 3); 
    }

    /** vsigmoidCD with a gain of 1 at the origin and drive (linear gain) of b
    
        Notes:
        - use for state saturation with odd order harmonics
        - needs makeup gain
    */
    SampleType vsigmoidCD_S (SampleType x, SampleType b)
    {
        return vsigmoidCD (b * x) * (ONE / b); 
    }

    /** An continuously differentiable algebraic sigmoid function. 

            f(x) = x / sqrt (x^2 + 1) 
    
        A cheap 'tanh' approximation
    */
    SampleType vsigmoidCD (SampleType x)
    {
        return x / sqrt (x * x + ONE);
    }

    /** Cutoff (Omega) modulation from an anhysteretic first-order nonlinear inductor circuit
    
        The linear cutoff is 1. Add a bias if a different linear cutoff is desired
        (i.e. vLan(x, N) + bias)
    */
    SampleType vLan (SampleType x, SampleType N)
    {
        return vpow (N * vabs (x) + ONE, 2);
    }

    /** Return 1 if x is positive, -1 if negative, and 0 otherwise */
    SampleType vsgn (SampleType x)
    {
        return SampleType (x[0] > 0 ? 1 : -1, x[1] > 0 ? 1 : -1);
    }

    /** Convert a cutoff in Hz to the cutoff gain of a TPT Onepole filter 
    
        Use case: convert float event parameters
    */
    SampleType vcutoffToG_Onepole (float x, float64 fs)
    {
        let Tpi = SampleType (pi / fs);
        
        let gOnepole = tanh (SampleType (x) * Tpi);

        return gOnepole / (ONE + gOnepole);
    }

    /** Convert an angular cutoff (in radians) to the cutoff gain of a TPT Onepole filter 
    
        Use case: convert SampleType stream parameters, 2x oversampling
    */
    SampleType vcutoffToG_OnepoleA (SampleType x, float64 fs)
    {
        let Tdiv2 = SampleType (1.0 / (2.0 * fs));

        let gOnepole = SampleType (x) * Tdiv2;

        return gOnepole / (ONE + gOnepole);
    }

    /** Convert gain to decibels and clamp results to greater than -100.0 dB */
    SampleType vgainTodB (SampleType x)
    {
        let b = vmax (NOISE_FLOOR, x);

        return SampleType (20.0) * log10 (b);
    }

    /** Convert decibels to gain and clamp inputs to greater than -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        let dB = vmax (NOISE_FLOOR_DB, x);

        return vpow (SampleType (10.0), dB * SampleType (1.0 / 20.0));
    }

    /** Convert a mix and a pan to a SampleType[2] gain array
    
        Use case: mix and pan 2 SampleType streams simultaneously
    */
    SampleType[2] vmixPanToGains (float m, float p)
    {
        let bPan = vpanToGains (p);
        let bMix = vmixToGains (m);

        return SampleType[2] (bMix.at(0) * bPan.at(0), bMix.at(1) * bPan.at(1));
    }

    /** Convert a mix value in range [0, 100] to a SampleType[2] gain array
    
        Use case: mix 2 SampleType streams
    */
    SampleType[2] vmixToGains (float x)
    {
        let b1 = SampleType (x) * SampleType (1.0/100.0);

        return SampleType[2] (ONE - b1, b1);
    }
    
    /** Convert a pan value in range [-1, 1] to a SampleType[2] gain array
    
        Use case: pan 2 SampleType streams simultaneously
    */
    SampleType[2] vpanToGains (float x)
    {
        let b1 = vpanToGain(x);

        return SampleType[2] (TWO - b1, b1);
    }

    /** Convert a linear pan value in range [-1, 1] to a SampleType gain 

        Use case: pan 1 SampleType stream
    */
    SampleType vpanToGain (float x)
    {
        let bR = float64 (x) + 1.0;

        return SampleType (2.0 - bR, bR);
    }

/*==============================================================================
Vectorized Intrinsic Functions                                          12/12/21
==============================================================================*/

    SampleType vabs (SampleType x)
    {
        return SampleType (abs (x[0]), abs (x[1]));
    }

    SampleType vmax (SampleType x0, SampleType x1)
    {
        return SampleType (max (x0[0], x1[0]), max (x0[1], x1[1]));
    }

    SampleType vmin (SampleType x0, SampleType x1)
    {
        return SampleType (min (x0[0], x1[0]), min (x0[1], x1[1]));
    }

    /** Vector reduce max */
    SampleType.elementType vmaxr (SampleType x)
    {
        return max (x[0], x[1]);
    }

    /** Vector reduce min */
    SampleType.elementType vminr (SampleType x)
    {
        return min (x[0], x[1]);
    }

    SampleType vclamp (SampleType x, SampleType lo, SampleType hi)
    {
        return SampleType (clamp (x[0], lo[0], hi[0]), clamp (x[1], lo[1], hi[1]));
    }

    /** 'pow' for int and SampleType exponents 
    
        T:
        - SampleType: vectorized version of pow with floating point arguments
        - int: repeated multiplicaton
    */
    SampleType vpow<T> (SampleType base, T exponent)
    {
        let T_isSampleType = T.isVector;

        static_assert ((T_isSampleType || T.isInt), "vpow [[Vectorized Intrinsic Functions]]");
        
        if const (T_isSampleType)
            return SampleType (pow (base[0], exponent[0]), pow (base[1], exponent[1]));
        else if const (T.isInt)
        {
            SampleType y = base;

            for (int i = 1; i < exponent; ++i)
                y *= base;

            return y;
        }
        return ZERO;
    }

    /** a < b ? trueStatement : falseStatement */
    SampleType viflt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] < b[0] ? trueStatement [0] : falseStatement [0], a[1] < b[1] ? trueStatement [1] : falseStatement [1]);
    }
    
    /** a > b ? trueStatement : falseStatement */
    SampleType vifgt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] > b[0] ? trueStatement [0] : falseStatement [0], a[1] > b[1] ? trueStatement [1] : falseStatement [1]);
    }

/*==============================================================================
Constants                                                               12/25/21
==============================================================================*/
    
    //soul::filters
    using SampleType = float64<2>; //also used internally as 'CoeffType'
    let updateInterval = 1024;
    namespace filt = soul::filters (SampleType, SampleType.elementType, updateInterval);

    //soul::oscillators
    namespace osc = soul::oscillators;
    
    //const SampleType
    let ZERO = SampleType (0.0);
    let HALF = SampleType (0.5);
    let ONE = SampleType (1.0);
    let TWO = SampleType (2.0);
    let COMP_MAX_GAIN = SampleType (1.9);
    let ADAA_TOL = SampleType (0.0000001);
    let NOISE_FLOOR = SampleType (0.00001);
    let NOISE_FLOOR_DB = SampleType (-100.0);
    
    //const float
    let SLEW_RATE_SECONDS_GAIN = 100.f;
    let DC_BLOCKER_CUTOFF_HZ = 1;

    //const int
    let MAX_BUFFER_SIZE = 22050; //for arrays of SampleType
    let MAX_BUFFER_SIZE_MS = 225; //MAX_BUFFER_SIZE in ms @ 96kHz floored to nearest multiple of 25
    let MAX_CUTOFF_HZ = 20000;
    let MIN_CUTOFF_HZ = 20;

} //namespace VA


/** Task List

    - OnepoleS constant c.G value and use soul::dBtoGain for primitives 
*/

namespace VA::Experimental
{
    // /** Onepole modified for state variable saturation

    //     Notes:
    //     - 2x oversampling recommended
    // */
    // namespace OnepoleS
    // {   
    //     struct Coeffs
    //     {
    //         SampleType b;
    //     }

    //     void update (Coeffs& c, float drive)
    //     {
    //         c.b = soul::dBtoGain (drive);
    //     }

    //     SampleType[2] process (Onepole::State& s, SampleType x, const Coeffs& c)
    //     {
    //         let v = (x - s.s);
    //         let lpf = v + s.s;
    //         let hpf = x - lpf;

    //         s.s = SampleType (0.25) * vsigmoidCD (c.b * (v + lpf));

    //         return SampleType[2] (lpf, hpf);
    //     }

    //     processor Processor (float iDrive)
    //     {
    //         input stream SampleType in;
    //         output stream SampleType lowpassOut, highpassOut;

    //         input event float driveIn [[ name: "Drive", min: 0, max: 20, init: iDrive, text: "dB" ]];

    //         event driveIn (float v) { drive = v; recalc = true; }

    //         float drive = dBtoGain (iDrive);
    //         bool recalc = true;

    //         void run()
    //         {   
    //             Onepole::State s;
    //             Coeffs c;

    //             let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

    //             loop
    //             {
    //                 if (recalc)
    //                 {
    //                     recalc = false;

    //                     c.update (drive);
    //                 }

    //                 loop (updateIntervalSamples)
    //                 {
    //                     let y = s.process (in, c);

    //                     lowpassOut << y[0];
    //                     highpassOut << y[1];

    //                     advance();
    //                 }
    //             }
    //         }
    //     }
    // }

    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SVF
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        SampleType[3] process (State& s, SampleType x, const Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor()
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            void run()
            {
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5); 

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = ONE / (ONE + TWO * R * c.a + c.a * c.a); //d
                    c.p = TWO * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }
} //namespace VA::Experimental
